(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";
// communication module
// module Communication {

var __extends = undefined && undefined.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
            d.__proto__ = b;
        } || function (d, b) {
            for (var p in b) {
                if (b.hasOwnProperty(p)) d[p] = b[p];
            }
        };
        return _extendStatics(d, b);
    };
    return function (d, b) {
        _extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", { value: true });
// }
var event_1 = require("./event");
var PageSocket = /** @class */function (_super) {
    __extends(PageSocket, _super);
    /**
     * socket communication between pages
     * @param context otherwindow
     * @param target otherwindow origin
     */
    function PageSocket(context, target) {
        var _this = _super.call(this) || this;
        _this._context = context;
        _this._target = target;
        window.addEventListener("message", _this.receiveMessage, false);
        return _this;
    }
    PageSocket.prototype.receiveMessage = function (event) {
        var origin = event.origin || event.originalEvent.origin;
        if (origin !== this._target) {
            this.event(event_1.Event.Error, "the target is error!");
        } else {
            this.event(event_1.Event.Message, event.data);
        }
    };
    /**
     * send data to the destination page
     * @param data string or arraybuffer
     */
    PageSocket.prototype.send = function (data) {
        this._context.postMessage(data, this._target);
    };
    return PageSocket;
}(event_1.EventEmitter);
exports.PageSocket = PageSocket;

},{"./event":2}],2:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var handler_1 = require("./handler");
/**
* @author confiner
* @desc 可调度事件的所有类的基类。
*/
// module Communication {
// }
var Event = /** @class */function () {
    function Event() {}
    Event.Message = "message";
    Event.Error = "error";
    return Event;
}();
exports.Event = Event;
var EventEmitter = /** @class */function () {
    function EventEmitter() {}
    /**
     * 检查 EvetEmitter 对象是否为特定事件类型注册了任何侦听器。
     * @param	type 事件的类型。
     * @return 如果指定类型的侦听器已注册，则值为 true；否则，值为 false。
     */
    EventEmitter.prototype.hasListener = function (type) {
        var listener = this._eventList && this._eventList[type];
        return !!listener;
    };
    /**
     * 派发事件。
     * @param type	事件类型。
     * @param data	（可选）回调数据。<b>注意：</b>如果是需要传递多个参数 p1,p2,p3,...可以使用数组结构如：[p1,p2,p3,...] ；如果需要回调单个参数 p ，且 p 是一个数组，则需要使用结构如：[p]，其他的单个参数 p ，可以直接传入参数 p。
     * @return 此事件类型是否有侦听者，如果有侦听者则值为 true，否则值为 false。
     */
    EventEmitter.prototype.event = function (type, data) {
        if (data === void 0) {
            data = null;
        }
        if (!this._eventList || !this._eventList[type]) return false;
        var listeners = this._eventList[type];
        if (listeners.run) {
            if (listeners.once) delete this._eventList[type];
            data != null ? listeners.runWith(data) : listeners.run();
        } else {
            for (var i = 0, n = listeners.length; i < n; i++) {
                var listener = listeners[i];
                if (listener) {
                    data != null ? listener.runWith(data) : listener.run();
                }
                if (!listener || listener.once) {
                    listeners.splice(i, 1);
                    i--;
                    n--;
                }
            }
            if (listeners.length === 0 && this._eventList) delete this._eventList[type];
        }
        return true;
    };
    /**
     * 使用 EventEmmiter 对象注册指定类型的事件侦听器对象，以使侦听器能够接收事件通知。
     * @param type		事件的类型。
     * @param caller	事件侦听函数的执行域。
     * @param listener	事件侦听函数。
     * @param args		（可选）事件侦听函数的回调参数。
     * @return 此 EvetEmitter 对象。
     */
    EventEmitter.prototype.on = function (type, caller, listener, args) {
        if (args === void 0) {
            args = null;
        }
        return this._createListener(type, caller, listener, args, false);
    };
    /**
     * 使用 EventEmitter 对象注册指定类型的事件侦听器对象，以使侦听器能够接收事件通知，此侦听事件响应一次后自动移除。
     * @param type		事件的类型。
     * @param caller	事件侦听函数的执行域。
     * @param listener	事件侦听函数。
     * @param args		（可选）事件侦听函数的回调参数。
     * @return 此 EventEmitter 对象。
     */
    EventEmitter.prototype.once = function (type, caller, listener, args) {
        if (args === void 0) {
            args = null;
        }
        return this._createListener(type, caller, listener, args, true);
    };
    /**@private */
    EventEmitter.prototype._createListener = function (type, caller, listener, args, once, offBefore) {
        if (offBefore === void 0) {
            offBefore = true;
        }
        //移除之前相同的监听
        offBefore && this.off(type, caller, listener, once);
        //使用对象池进行创建回收
        var handler = handler_1.Handler.create(caller || this, listener, args, once);
        this._eventList || (this._eventList = {});
        var events = this._eventList;
        //默认单个，每个对象只有多个监听才用数组，节省一个数组的消耗
        if (!events[type]) events[type] = handler;else {
            if (!events[type].run) events[type].push(handler);else events[type] = [events[type], handler];
        }
        return this;
    };
    /**
     * 从 EventEmitter 对象中删除侦听器。
     * @param type		事件的类型。
     * @param caller	事件侦听函数的执行域。
     * @param listener	事件侦听函数。
     * @param onceOnly	（可选）如果值为 true ,则只移除通过 once 方法添加的侦听器。
     * @return 此 EventEmitter 对象。
     */
    EventEmitter.prototype.off = function (type, caller, listener, onceOnly) {
        if (onceOnly === void 0) {
            onceOnly = false;
        }
        if (!this._eventList || !this._eventList[type]) return this;
        var listeners = this._eventList[type];
        if (listener != null) {
            if (listeners["run"]) {
                if ((!caller || listeners["caller"] === caller) && listeners["method"] === listener && (!onceOnly || listeners["once"])) {
                    delete this._eventList[type];
                    listeners["recover"].apply(this);
                }
            } else {
                var count = 0;
                var n = listeners["length"];
                for (var i = 0; i < n; i++) {
                    var item = listeners[i];
                    if (item && (!caller || item.caller === caller) && item.method === listener && (!onceOnly || item.once)) {
                        count++;
                        listeners[i] = null;
                        item.recover();
                    }
                }
                //如果全部移除，则删除索引
                if (count === n) delete this._eventList[type];
            }
        }
        return this;
    };
    /**
     * 从 EventEmitter 对象中删除指定事件类型的所有侦听器。
     * @param type	（可选）事件类型，如果值为 null，则移除本对象所有类型的侦听器。
     * @return 此 EventEmitter 对象。
     */
    EventEmitter.prototype.offAll = function (type) {
        if (type === void 0) {
            type = null;
        }
        var events = this._eventList;
        if (!events) return this;
        if (type) {
            this._recoverHandlers(events[type]);
            delete events[type];
        } else {
            for (var name_1 in events) {
                this._recoverHandlers(events[name_1]);
            }
            this._eventList = null;
        }
        return this;
    };
    EventEmitter.prototype._recoverHandlers = function (arr) {
        if (!arr) return;
        if (arr.run) {
            arr.recover();
        } else {
            for (var i = arr.length - 1; i > -1; i--) {
                if (arr[i]) {
                    arr[i].recover();
                    arr[i] = null;
                }
            }
        }
    };
    return EventEmitter;
}();
exports.EventEmitter = EventEmitter;
// class EventHandler extends Handler {
// 	/**@private handler对象池*/
// 	private static _eventPool: Array<Handler> = [];
// 	public constructor(caller: any, method: Function, args: any, once: boolean) {
// 		super();
// 		this.setTo(caller, method, args, once);
// 	}
// 	public recover(): void {
// 		if (this._id > 0) {
// 			this._id = 0;
// 			EventHandler._eventPool.push(this.clear());
// 		}
// 	}
// 	/**
// 	 * 从对象池内创建一个Handler，默认会执行一次回收，如果不需要自动回收，设置once参数为false。
// 	 * @param caller	执行域(this)。
// 	 * @param method	回调方法。
// 	 * @param args		（可选）携带的参数。
// 	 * @param once		（可选）是否只执行一次，如果为true，回调后执行recover()进行回收，默认为true。
// 	 * @return 返回创建的handler实例。
// 	 */
// 	public static create(caller: any, method: Function, args: any = null, once: boolean = true): Handler {
// 		if (EventHandler._eventPool.length)
// 			return (EventHandler._eventPool.pop()).setTo(caller, method, args, once);
// 		return new EventHandler(caller, method, args, once);
// 	}
// }

},{"./handler":3}],3:[function(require,module,exports){
"use strict";
// module Communication {

Object.defineProperty(exports, "__esModule", { value: true });
// }
var Handler = /** @class */function () {
    /**
     * 根据指定的属性值，创建一个 <code>Handler</code> 类的实例。
     * @param	caller 执行域。
     * @param	method 处理函数。
     * @param	args 函数参数。
     * @param	once 是否只执行一次。
     */
    function Handler(caller, method, args, once) {
        if (caller === void 0) {
            caller = null;
        }
        if (method === void 0) {
            method = null;
        }
        if (args === void 0) {
            args = null;
        }
        if (once === void 0) {
            once = false;
        }
        this.caller = null;
        this.method = null;
        this.args = null;
        this.once = false;
        this._id = 0;
        this.setTo(caller, method, args, once);
    }
    /**
     * 设置此对象的指定属性值。
     * @param	caller 执行域(this)。
     * @param	method 回调方法。
     * @param	args 携带的参数。
     * @param	once 是否只执行一次，如果为true，执行后执行recover()进行回收。
     * @return  返回 handler 本身。
     */
    Handler.prototype.setTo = function (caller, method, args, once) {
        this._id = Handler._gid++;
        this.caller = caller;
        this.method = method;
        this.args = args;
        this.once = once;
        return this;
    };
    /**
     * 执行处理器。
     */
    Handler.prototype.run = function () {
        if (!this.method) return null;
        var id = this._id;
        console.log(this.method);
        var result = this.method.apply(this.caller, this.args);
        this._id === id && this.once && this.recover();
        return result;
    };
    /**
     * 执行处理器，携带额外数据。
     * @param	data 附加的回调数据，Array
     */
    Handler.prototype.runWith = function (data) {
        if (!this.method) return null;
        var id = this._id;
        var result = null;
        if (!data) result = this.method.apply(this.caller, this.args);else if (this.args) {
            result = this.method.apply(this.caller, this.args.concat(data));
        } else {
            console.log(this.method);
            result = this.method.apply(this.caller, data);
        }
        this._id === id && this.once && this.recover();
        return result;
    };
    /**
     * 清理对象引用。
     */
    Handler.prototype.clear = function () {
        this.caller = null;
        this.method = null;
        this.args = null;
        return this;
    };
    /**
     * 清理并回收到 Handler 对象池内。
     */
    Handler.prototype.recover = function () {
        if (this._id > 0) {
            this._id = 0;
            Handler._pool.push(this.clear());
        }
    };
    /**
     * 从对象池内创建一个Handler，默认会执行一次并立即回收，如果不需要自动回收，设置once参数为false。
     * @param	caller 执行域(this)。
     * @param	method 回调方法。
     * @param	args 携带的参数。
     * @param	once 是否只执行一次，如果为true，回调后执行recover()进行回收，默认为true。
     * @return  返回创建的handler实例。
     */
    Handler.create = function (caller, method, args, once) {
        if (args === void 0) {
            args = null;
        }
        if (once === void 0) {
            once = true;
        }
        if (Handler._pool.length) return Handler._pool.pop().setTo(caller, method, args, once);
        return new Handler(caller, method, args, once);
    };
    Handler._pool = [];
    Handler._gid = 1;
    return Handler;
}();
exports.Handler = Handler;

},{}],4:[function(require,module,exports){
"use strict";

function __export(m) {
    for (var p in m) {
        if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(require("./communication"));
__export(require("./event"));
__export(require("./handler"));

},{"./communication":1,"./event":2,"./handler":3}]},{},[4])

//# sourceMappingURL=page-communication.min.js.map
