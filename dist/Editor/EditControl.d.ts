import { AbstractMesh, Camera, Mesh, Quaternion, Vector3 } from 'babylonjs';
export declare class EditControl {
    private _mesh;
    private _canvas;
    private _scene;
    private _mainCamera;
    private _ecRoot;
    private _local;
    private _snapT;
    private _snapR;
    private _transSnap;
    private _rotSnap;
    private _axesLen;
    private _axesScale;
    private _pickWidth;
    private _redMat;
    private _greenMat;
    private _blueMat;
    private _whiteMat;
    private _yellowMat;
    private _actHist;
    private _renderer;
    private _pointerdown;
    private _pointerup;
    private _pointermove;
    private _visibility;
    constructor(mesh: Mesh, camera: Camera, canvas: HTMLCanvasElement, scale?: number, eulerian?: boolean, pickWidth?: number);
    private _checkQuaternion;
    private _ecMatrix;
    private _ecTOcamera;
    private _renderLoopProcess;
    private _setECRotation;
    private _isScaleUnEqual;
    private _distFromCamera;
    private _cameraTOec;
    private _cameraNormal;
    private _setECScale;
    private _rotRotGuides;
    private _rotPlanarGuides;
    switchTo(mesh: Mesh, eulerian?: boolean): void;
    setUndoCount(c: number): void;
    undo(): void;
    redo(): void;
    detach(): void;
    private _prevState;
    private _hidden;
    hide(): void;
    private _hideCommonAxes;
    private _showCommonAxes;
    show(): void;
    isHidden(): boolean;
    private _disposeAll;
    private _actionListener;
    private _actionStartListener;
    private _actionEndListener;
    addActionListener(actionListener: (actionType: number) => void): void;
    removeActionListener(): void;
    addActionStartListener(actionStartListener: (actionType: number) => void): void;
    removeActionStartListener(): void;
    addActionEndListener(actionEndListener: (actionType: number) => void): void;
    removeActionEndListener(): void;
    removeAllActionListeners(): void;
    private _pDown;
    private _axisPicked;
    private _onPointerDown;
    private _setEditing;
    isEditing(): boolean;
    private _detachCamera;
    private _prevOverMesh;
    private _pointerIsOver;
    isPointerOver(): boolean;
    private _savedMat;
    private _savedCol;
    private _onPointerOver;
    private _clearPrevOverMesh;
    private _restoreColor;
    private _editing;
    private _onPointerUp;
    private _actionType;
    private _setActionType;
    private _callActionListener;
    private _callActionStartListener;
    private _callActionEndListener;
    private _prevPos;
    private _onPointerMove;
    private _rotate2;
    private _getPickPlane;
    private _transBy;
    private _doTranslation;
    private _snapTV;
    private _transWithSnap;
    private _snapS;
    private _snapSV;
    private _scaleSnap;
    private _scale;
    private _doScaling;
    private _scaleWithSnap;
    private _localX;
    private _localY;
    private _localZ;
    private _setLocalAxes;
    private _boundingDimesion;
    private _getBoundingDimension;
    refreshBoundingInfo(): void;
    private _eulerian;
    private _snapRA;
    private _doRotation;
    private _getPosOnPickPlane;
    private _hideBaxis;
    private _setAxesVisiblity;
    getRotationQuaternion(): Quaternion;
    getPosition(): Vector3;
    private _transEnabled;
    isTranslationEnabled(): boolean;
    enableTranslation(): void;
    disableTranslation(): void;
    private _rotEnabled;
    isRotationEnabled(): boolean;
    returnEuler(euler: boolean): void;
    enableRotation(): void;
    disableRotation(): void;
    private _scaleEnabled;
    isScalingEnabled(): boolean;
    enableScaling(): void;
    disableScaling(): void;
    private _scaleBoundsMin;
    private _scaleBoundsMax;
    setScaleBounds(min?: Vector3, max?: Vector3): void;
    removeScaleBounds(): void;
    private _transBoundsMin;
    private _transBoundsMax;
    setTransBounds(min?: Vector3, max?: Vector3): void;
    removeTransBounds(): void;
    private _rotBoundsMin;
    private _rotBoundsMax;
    setRotBounds(min?: Vector3, max?: Vector3): void;
    removeRotBounds(): void;
    private _bXaxis;
    private _bYaxis;
    private _bZaxis;
    private _xaxis;
    private _yaxis;
    private _zaxis;
    private _createCommonAxes;
    private _pickedPlane;
    private _pALL;
    private _pXZ;
    private _pZY;
    private _pYX;
    private _createPickPlanes;
    private _tCtl;
    private _tX;
    private _tY;
    private _tZ;
    private _tXZ;
    private _tZY;
    private _tYX;
    private _tAll;
    private _tEndX;
    private _tEndY;
    private _tEndZ;
    private _tEndXZ;
    private _tEndZY;
    private _tEndYX;
    private _tEndAll;
    private _createTransAxes;
    private _createTriangle;
    private _rCtl;
    private _rX;
    private _rY;
    private _rZ;
    private _rAll;
    private _rEndX;
    private _rEndY;
    private _rEndZ;
    private _rEndAll;
    private _rEndAll2;
    private _guideSize;
    setRotGuideFull(y: boolean): void;
    private _createRotAxes;
    private _extrudeBox;
    private _createCircle;
    private _createTube;
    private _sCtl;
    private _sX;
    private _sY;
    private _sZ;
    private _sXZ;
    private _sZY;
    private _sYX;
    private _sAll;
    private _sEndX;
    private _sEndY;
    private _sEndZ;
    private _sEndXZ;
    private _sEndZY;
    private _sEndYX;
    private _sEndAll;
    private _createScaleAxes;
    private _check_LHS_RHS;
    setVisibility(v: number): void;
    setLocal(l: boolean): void;
    isLocal(): boolean;
    setTransSnap(s: boolean): void;
    setRotSnap(s: boolean): void;
    setScaleSnap(s: boolean): void;
    private _tSnap;
    setTransSnapValue(t: number): void;
    setRotSnapValue(r: number): void;
    setScaleSnapValue(r: number): void;
    private _tv1;
    private _tv2;
    private _tv3;
    private _tm;
    private _getAngle2;
    private _getAngle;
    private _createMaterials;
    private _disposeMaterials;
    private static _getStandardMaterial;
}
export declare class ActHist {
    private mesh;
    private lastMax;
    private acts;
    private last;
    private current;
    constructor(mesh: AbstractMesh, capacity: number);
    setCapacity(c: number): void;
    add(at?: number): void;
    undo(): number;
    redo(): number;
}
export declare class Act {
    private _p;
    private _rQ;
    private _rE;
    private _s;
    private _at;
    constructor(mesh: AbstractMesh, at: number);
    getActionType(): number;
    perform(mesh: AbstractMesh): void;
}
